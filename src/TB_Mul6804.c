/*
 * TB_Mul6804.c
 *
 *  Created on: 2018年10月26日
 *      Author: WangHongBo
 */
#include "TB_Mul6804.h"

#define SPITRCMD	67
#define SPICMDLEN	12

#define UCHAR unsigned char

//6804的命令行
#define WRCFG1 	 	(1)
#define WRCFG2 		(2)
#define WRCFG3 		(3)

#define DIAGN1		(4)//多路复用自检
#define DIAGN2		(5)
#define	DIAGN3		(6)

#define CVST1		(7)//数字滤波器自检
#define CVST2		(8)
#define CVST3		(9)

#define	AXST1		(10)//数字滤波器自检
#define	AXST2		(11)
#define	AXST3		(12)

#define	CSTATS1		(13)//数字滤波器自检
#define	CSTATS2		(14)
#define	CSTATS3		(15)

#define ADOWU1  	(16)//断线自检
#define ADOWU2		(17)
#define ADOWU3		(18)
#define ADOWD1 		(19)
#define ADOWD2 		(20)
#define ADOWD3		(21)


#define ADCV1 		(25)//启动电池电压转换
#define ADCV2 		(26)
#define ADCV3		(27)

#define RDCVA1 		(28)//读取电池电压
#define RDCVB1 		(29)
#define RDCVC1 		(30)
#define RDCVD1 	 	(31)
#define RDCVA2		(32)
#define RDCVB2		(33)
#define RDCVC2 		(34)
#define RDCVD2 		(35)
#define RDCVA3 		(36)
#define RDCVB3  	(37)
#define RDCVC3      (38)
#define RDCVD3 		(39)

#define ADCVAX1     (40)//开始GPIO引脚的ADC转换
#define ADCVAX2 	(41)
#define ADCVAX3 	(42)

#define RDAUXA1		(43)//读取辅助寄存器A,B
#define RDAUXB1 	(44)
#define RDAUXA2	 	(45)
#define RDAUXB2 	(46)
#define RDAUXA3	 	(47)
#define RDAUXB3 	(48)

#define ADSTAT1     (49)//开始芯片状态的ADC转换
#define ADSTAT2     (50)
#define ADSTAT3     (51)

#define RDSTATA1    (52)//读取相应的状态寄存器组A,B
#define RDSTATA2    (53)
#define RDSTATA3    (54)

#define RDSTATB1    (55)
#define RDSTATB2    (56)
#define RDSTATB3    (57)

#define WAITADV		(70)
#define SPIWAIT2 	(71)
#define SPIWAIT3 	(72)
#define SPIHOLD 	(73)
#define SPIRESET    (74)
#define WAITADU		(75)
#define WAITSTATE   (76)
/**********新添加的关于被动均衡的宏定义*//////////
#define WRCFG1AO	(58)
#define WRCFG2AO	(59)
#define WRCFG3AO	(60)
#define WRCFG1AN	(61)
#define WRCFG2AN	(62)
#define WRCFG3AN	(63)
#define WAKEUP		(77)//关于唤醒

//转换命令数组
UCHAR SPIDATA2Mul[SPITRCMD][SPICMDLEN]={
	 //1    2    3    4    5    6    7    8    9    10   11   12
    0x80,0x01,0x4D,0x7A,0xF8,0x00,0x00,0x00,0x00,0x30,0xBE,0xE0,//WRCFG1    (0)
    0xC0,0x01,0x75,0x70,0xF8,0x00,0x00,0x00,0x00,0x30,0xBE,0xE0,//WRCFG2		(1)
    0xE0,0x01,0xAC,0xEC,0xF8,0x00,0x00,0x00,0x00,0x30,0xBE,0xE0,//WRCFG3		(2)
    0x87,0x15,0x08,0x4A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//DIAGN1		(3)
    0xC7,0x15,0x30,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//DIAGN2		(4)
    0xE7,0x15,0xE9,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//DIAGN3		(5)
    0x83,0x27,0xC4,0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//CVST1			(6)
    0xC3,0x27,0xFC,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//CVST2			(7)
    0xE3,0x27,0x25,0x9E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//CVST3			(8)
    0x85,0x27,0xE3,0xC4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//AXST1			(9)
    0xC5,0x27,0xDB,0xCE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//AXST2			(10)
    0xE5,0x27,0x02,0x52,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//AXST3			(11)
    0x85,0x2F,0x0B,0xCA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//CSTATS1		(12)
    0xC5,0x2F,0x33,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//CSTATS2		(13)
    0xE5,0x2F,0xEA,0x5C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//CSTATS3		(14)

    0x83,0x78,0x37,0x58,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADOWU1  	(15)
    0xC3,0x78,0x0F,0x52,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADOWU2		(16)
    0xE3,0x78,0xD6,0xCE,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADOWU3		(17)

    0x83,0x38,0xD0,0xD2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADOWD1 		(18)
    0xC3,0x38,0xE8,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADOWD2 		(19)
    0xE3,0x38,0x31,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADOWD3		(20)

    0x80,0x01,0x4D,0x7A,0xFC,0x00,0x00,0x00,0xFF,0x3F,0x4C,0x36,//WRCFG1O		(21)
    0xC0,0x01,0x75,0x70,0xFC,0x00,0x00,0x00,0xFF,0x3F,0x4C,0x36,//WRCFG1O		(22)
    0xE0,0x01,0xAC,0xEC,0xFC,0x00,0x00,0x00,0xFF,0x3F,0x4C,0x36,//WRCFG1O		(23)
    0x83,0x70,0xDF,0x56,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADCV1 		(24)
    0xC3,0x70,0xE7,0x5C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADCV2 		(25)
    0xE3,0x70,0x3e,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADCV3			(26)
    0x80,0x04,0x77,0xD6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVA1 		(27)
    0x80,0x06,0xEA,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVB1 		(28)
    0x80,0x08,0x2E,0x46,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVC1 		(29)
    0x80,0x0a,0xB3,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVD1 	 	(30)
    0xC0,0x04,0x4F,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVA2		(31)
    0xC0,0x06,0xD2,0x8A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVB2		(32)
    0xC0,0x08,0x16,0x4C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVC2 		(33)
    0xC0,0x0a,0x8B,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVD2 		(34)
    0xE0,0x04,0x96,0x40,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVA3 		(35)
    0xE0,0x06,0x0B,0x16,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVB3  	(36)
    0xE0,0x08,0xCF,0xD0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVC3    (37)
    0xE0,0x0a,0x52,0x86,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDCVD3 		(38)
    0x85,0x60,0xA3,0xB4,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADCVAX1   (39)
    0xC5,0x60,0x9B,0xbe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADCVAX2 		(40)
    0xE5,0x60,0x42,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADCVAX3 		(41)

    0x80,0x0c,0x9F,0xD8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDAUXA1		  (42)
    0x80,0x0e,0x02,0x8E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDAUXB1 	  (43)
    0xC0,0x0c,0xA7,0xD2,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDAUXA2	 	  (44)
    0xC0,0x0e,0x3A,0x84,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDAUXB2 		(45)
    0xE0,0x0c,0x7E,0x4E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDAUXA3	 	  (46)
    0xE0,0x0e,0xE3,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDAUXB3 		(47)

    0x85,0x68,0x4B,0xBA,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADSTAT1 		 (48)
    0xC5,0x68,0x73,0xB0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADSTAT2 		 (49)
    0xE5,0x68,0xAA,0x2C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//ADSTAT3 		 (50)

    0x80,0x10,0x9D,0x66,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDSTATA1     (51)
    0xC0,0x10,0xA5,0x6C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDSTATA2     (52)
    0xE0,0x10,0x7C,0xF0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDSTATA3     (53)

    0x80,0x12,0x00,0x30,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDSTATB1     (54)
    0xC0,0x12,0x38,0x3A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDSTATB2     (55)
    0xE0,0x12,0xE1,0xA6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//RDSTATB3      (56)
		/************新加入的有关被动均衡的命令*************************************/
    0x80,0x01,0x4D,0x7A,0xFC,0x00,0x00,0x00,0x55,0x35,0xF8,0xB2,//WRCFG1AO		(57)
    0xC0,0x01,0x75,0x70,0xFC,0x00,0x00,0x00,0x55,0x35,0xF8,0xB2,//WRCFG2AO		(58)
    0xE0,0x01,0xAC,0xEC,0xFC,0x00,0x00,0x00,0x55,0x35,0xF8,0xB2,//WRCFG3AO		(59)
    0x80,0x01,0x4D,0x7A,0xFC,0x00,0x00,0x00,0x00,0x00,0x4F,0x82,//WRCFG1AN		(60)
    0xC0,0x01,0x75,0x70,0xFC,0x00,0x00,0x00,0x00,0x00,0x4F,0x82,//WRCFG2AN		(61)
    0xE0,0x01,0xAC,0xEC,0xFC,0x00,0x00,0x00,0x00,0x00,0x4F,0x82, //WRCFG3AN		(62)
    0x80,0x02,0x5B,0x1E,0xFC,0x00,0x00,0x00,0x00,0x00,0x4F,0x82,//RDCFG1		(63)
    0xC0,0x02,0x63,0x14,0xFC,0x00,0x00,0x00,0x00,0x00,0x4F,0x82,//RDCFG2		(64)
    0xE0,0x02,0xBA,0x88,0xFC,0x00,0x00,0x00,0x00,0x00,0x4F,0x82 //RDCFG3		(65)
};
//命令的有效字节数
volatile unsigned char SPIDATALEN2Mul[SPITRCMD]=
{
    //1 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30
     12,12,12,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,04,12,12,12,04,04,04,12,12,12,
   //31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60
     12,12,12,12,12,12,12,12,12,04,04,04,12,12,12,12,12,12,04,04,04,12,12,12,12,12,12,12,12,12,
   //61 62 63 64 65 66,66
     12,12,12,12,12,12,12
};

UCHAR wakeupcnt = 0;
UCHAR SPI_TransmitEnd = 1;
UCHAR sendenable = 0;
UCHAR gCommandTypeMul = 1;
UCHAR SPILINEMul = 0;
UCHAR WaitTime = 30;
unsigned char g_SPI_Rx_arrayMul[51][12] = {0};//SPI接收数据的数组
unsigned long ResetTime = 30000;
const UCHAR ADCWaitTime = 40;

void delay_testMul(unsigned char t)
{
	int i,j;
	j=50000;
	for(i=0;i<t;i++)
	{
		while(j > 0)
			j--;
	}
}
//SPI_3  发送单个数据(最后一个字节)
uint8_t SPI_DataSendMul(uint8_t Data_Tx)
{
	uint8_t RecDataMaster;
	//SPI_3.SR.B.TCF = 1;    //将发送完成位清零
	//0x0801  为配置信息；0x5678为要发送的数据;CONT位不要轻易开，会出问题
	SPI_3.PUSHR.PUSHR.R  =  0x08020000 | (Data_Tx & 0x0000FFFF);     /* Transmit data from master to slave SPI with EOQ */
	//while(SPI_3.SR.B.TCF!=1); //Wait for transfer complete

	while (SPI_3.SR.B.RFDF != 1){}           //等待接收FIFO上溢，即：接收完数据
	RecDataMaster = SPI_3.POPR.R;            //读取主机接收到的数据
	SPI_3.SR.B.RFDF = 1;

	return RecDataMaster;
}
//SPI_3  发送单个数据(中间字节)
uint8_t SPI_mid_DataSendMul(uint8_t Data_Tx)
{
	uint8_t RecDataMaster;
	//SPI_3.SR.B.TCF = 1;    //将发送完成位清零
	//0x0801  为配置信息；0x5678为要发送的数据;CONT位不要轻易开，会出问题
	SPI_3.PUSHR.PUSHR.R  =  0x80020000 | (Data_Tx & 0x0000FFFF);     /* Transmit data from master to slave SPI with EOQ */
	//while(SPI_3.SR.B.TCF!=1); //Wait for transfer complete

	while (SPI_3.SR.B.RFDF != 1){}           //等待接收FIFO上溢，即：接收完数据
	RecDataMaster = SPI_3.POPR.R;            //读取主机接收到的数据
	SPI_3.SR.B.RFDF = 1;
	return RecDataMaster;
}
void DataOrganizationMul()
{
    if (SPI_TransmitEnd == 1)
    {
		switch(gCommandTypeMul)
		{
			case WRCFG1:
			{
				SPILINEMul = WRCFG1 - 1;
				gCommandTypeMul = WRCFG2;
				sendenable = 1;
				break;
			}
			case WRCFG2:
			{
				SPILINEMul = WRCFG2 - 1;
				gCommandTypeMul = ADCV1;
				sendenable = 1;
				break;
			}
			case WRCFG3:
			{
				SPILINEMul = WRCFG3 - 1;
				//跳到启动AD电压转换
				gCommandTypeMul =ADCV1;
				sendenable = 1;
				break;
			}
			/*
			case WAKEUP:
			{
				if(wakeupcnt < 5)
				{
					wakeupcnt++;
					if(wakeupcnt == 1)
					{
						CSB_pin = 0;
					}
					if(wakeupcnt == 2)
					{
						CSB_pin = 1;
					}
					if(wakeupcnt == 3)
					{
						CSB_pin = 0;
					}
				}
				else
				{
					gCommandTypeMul = index;
					wakeupcnt = 0;
				}
				///gCommandTypeMul = ADCV1;
				break;
			}
			*/
			case ADCV1:
			{
				SPILINEMul = ADCV1 - 1;
				gCommandTypeMul = ADCV2;
				sendenable = 1;
				break;
			}
			case ADCV2:
			{
				SPILINEMul = ADCV2 - 1;
				gCommandTypeMul = WAITADV;//ADCV3;
				sendenable = 1;
				break;
			}
			case ADCV3:
			{
				SPILINEMul = ADCV3 - 1;
				gCommandTypeMul=WAITADV;
				sendenable = 1;
				break;
			}
			case WAITADV:
			{
				if (WaitTime == 0)
				{
					WaitTime = ADCWaitTime;
					gCommandTypeMul = RDCVA1;
				}
				else
				{
					WaitTime--;
				}
				break;
			}
			case RDCVA1:
			{
				SPILINEMul = RDCVA1 - 1;
				gCommandTypeMul=RDCVB1;
				sendenable = 1;
				break;
			}
			case RDCVB1:
			{
				SPILINEMul = RDCVB1 - 1;
				gCommandTypeMul=RDCVC1;
				sendenable = 1;
				break;
			}
			case RDCVC1:
			{
				SPILINEMul = RDCVC1 - 1;
				gCommandTypeMul=RDCVD1;
				sendenable = 1;
				break;
			}
			case RDCVD1:
			{
				SPILINEMul = RDCVD1 - 1;
				gCommandTypeMul = RDCVA2;
				sendenable = 1;
				break;

			}
			case RDCVA2:
			{
				SPILINEMul = RDCVA2 - 1;
				gCommandTypeMul=RDCVB2;
				sendenable = 1;
				break;
			}
			case RDCVB2:
			{
				SPILINEMul = RDCVB2 - 1;
				gCommandTypeMul=RDCVC2;
				sendenable = 1;
				break;
			}
			case RDCVC2:
			{
				SPILINEMul = RDCVC2 - 1;
				gCommandTypeMul=RDCVD2;
				sendenable = 1;
				break;
			}
			case RDCVD2:
			{
				SPILINEMul = RDCVD2 - 1;
				gCommandTypeMul=SPIRESET;
				sendenable = 1;
				break;

			}
			case RDCVA3:
			{
				SPILINEMul = RDCVA3 - 1;
				gCommandTypeMul=RDCVB3;
				sendenable = 1;
				break;
			}
			case RDCVB3:
			{
				SPILINEMul = RDCVB3 - 1;
				gCommandTypeMul=RDCVC3;
				sendenable = 1;
				break;
			}
			case RDCVC3:
			{
				SPILINEMul = RDCVC3 - 1;
				gCommandTypeMul=RDCVD3;
				sendenable = 1;
				break;
			}
			case RDCVD3:
			{
				SPILINEMul = RDCVD3 - 1;
				gCommandTypeMul = SPIRESET;
				sendenable = 1;
				break;
			}
			case SPIRESET:
			{
				if (ResetTime == 0)
				{
					gCommandTypeMul=WRCFG1;
					ResetTime = 30000;
				}
				else
				{
					ResetTime--;
				}
				break;
			}
		}
    }
}
void vol_sample_Mul(int cell[][12])
{
	static int i=0,num = 0;
	static unsigned char temp=0;
	static unsigned char rows = 0;
	static int tmp[6] = {0};

	uint8_t recNum = 0;

	if(sendenable == 0)
		DataOrganizationMul();
	if(i<SPIDATALEN2Mul[SPILINEMul] && sendenable == 1)
	{
		if(temp != SPILINEMul)//此时为刷新步骤的接收报文序号
		{
			temp = SPILINEMul;
			rows = 0;
		}
		if(i == 0)	//开始发送， CS0拉低
		{
			SIUL2.GPDO[PD10].R  = 0;
			delay_testMul(1);
		}
		if(i < SPIDATALEN2Mul[SPILINEMul]-1)	//正在发送，非最后一个字节
			recNum = SPI_mid_DataSendMul(SPIDATA2Mul[SPILINEMul][i++]);
		else if(i == SPIDATALEN2Mul[SPILINEMul]-1)	//正在发送，最后一个字节
			recNum = SPI_DataSendMul(SPIDATA2Mul[SPILINEMul][i++]);
		if(i == SPIDATALEN2Mul[SPILINEMul])	//发送完成， CS0拉高
		{
			delay_testMul(1);
			SIUL2.GPDO[PD10].R  = 1;
		}
		g_SPI_Rx_arrayMul[temp][rows++] = recNum;
	}
	else if(i==SPIDATALEN2Mul[SPILINEMul])
	{
		//清零， 以DataOrganization()函数继续执行指令
		sendenable =0;
		i=0;
	}
	//RESET时读取数据
	if(gCommandTypeMul == SPIRESET)
	{

		for(num=27; num<35; num++)
		{
			UCHAR row_temp = (num-27)>>2;
			UCHAR col_temp = (num-27-(row_temp<<2))*3;
			cell[row_temp][col_temp] =  ((unsigned short)(g_SPI_Rx_arrayMul[num][5]) << 8) + (unsigned short)g_SPI_Rx_arrayMul[num][4];
			cell[row_temp][col_temp+1] =  ((unsigned short)(g_SPI_Rx_arrayMul[num][7]) << 8) + (unsigned short)g_SPI_Rx_arrayMul[num][6];
			cell[row_temp][col_temp+2] =  ((unsigned short)(g_SPI_Rx_arrayMul[num][9]) << 8) + (unsigned short)g_SPI_Rx_arrayMul[num][8];
		}
		/*
		for(num=7+Num_6804*NUM_COMMAND; num < limit; num++)
		{
			tmp[(num-index_t)*3] =  ((unsigned short)(g_SPI_Rx_array[num][5]) << 8) + (unsigned short)g_SPI_Rx_array[num][4];
			tmp[(num-index_t)*3+1] =  ((unsigned short)(g_SPI_Rx_array[num][7]) << 8) + (unsigned short)g_SPI_Rx_array[num][6];
			tmp[(num-index_t)*3+2] =  ((unsigned short)(g_SPI_Rx_array[num][9]) << 8) + (unsigned short)g_SPI_Rx_array[num][8];
		}*/
	}
}
